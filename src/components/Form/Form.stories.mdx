import {
  Meta,
  Story,
  Preview,
  Props,
  Example,
} from '@storybook/addon-docs/blocks';

import Examples from './Form.stories.examples';

import Form from './Form.component';
import FormField from 'components/molecules/FormField';
import validators from 'store/FormProvider/validators';
import * as Styled from './Form.styles';
import InputField from 'components/molecules/InputField';
import Checkbox from 'components/molecules/Checkbox';
import InfoBox from 'components/molecules/InfoBox';

<Meta title="Core|Organisms/Form" />

# Form Component

Form component is form wrapper element that contains input elements as children.

Instead of using plain input elements and pass them as the children, we are going to be using
[FormField](/?path=/docs/core-molecules-formfield--default-story)

So, basically, Form components consists of multiple [FormFields](/?path=/docs/core-molecules-formfield--default-story)

Understanding form component implies you understand the following:

1. `FormContext`
2. `FormProvider`
3. [FormField](/?path=/docs/core-molecules-formfield--default-story)

_Note: FormContext & FormProvider are described below_

# FormContext

We use `FormContext` in order to have standardized API to our Form, so that we can easily
control it.

As you can see in interface below some of the functions sound familiar.

The context itself serves the purpose of managing all the data of currently dispalyed form.
As well as information about validity of the form.

```ts
interface FormContext {
  fields: FormState;
  formValid: boolean;
  registerField: (name: string) => void;
  setFieldError: (name: string, error: string) => void;
  markAsDirty: (name: string) => void;
  markAsTouched: (name: string) => void;
  markAllAsDirtyAndTouched: () => void;
  reportFieldValidity: (name: string, valid: boolean) => void;
  updateValueField: (name: string, value: any) => void;
}
```

# FormProvider

`FormProvider` is a context provider created via [React Context API](https://reactjs.org/docs/context.html)

It provides the values for the above mentioned `FormContext`

```tsx
<FormContext.Provider
  value={{
    fields,
    formValid,
    registerField,
    setFieldError,
    markAsDirty,
    markAsTouched,
    markAllAsDirtyAndTouched,
    reportFieldValidity,
    updateValueField,
  }}
>
  {children}
</FormContext.Provider>
```

_Note: you can find detailed implementation in the code_

# FormField

`FormField` represents a single field inside of the form. E.g. => `InputField`

It also connects to the `FormContext` in order to register itself and give control to the `FormProvider`.

Adding `FormField` is easy. You only need to pass which component you want it to render.

Validation is optional.

And you can pass all the props just by writing them as the props of the `FormField`.

You can read more about `FormField` [here](/?path=/docs/core-molecules-formfield--default-story).

```tsx
/* Form field example */

<FormField
  name="firstName"
  component={InputField}
  placeholder="First name"
  validate={validators.general.required('Please fill in this field')}
/>
```

---

Having an understanding of what `FormContext`, `FormProvider` and `FormField` are
we can continue to examples

# Default form with live validation

---

<Story name="default">
  <Examples.DefaultForm />
</Story>

```tsx
<Form
  onSubmit={data => {
    console.log(data);
  }}
>
  <Examples.ListView>
    <FormField
      name="firstName"
      component={InputField}
      placeholder="First name"
      validate={[
        validators.general.required('Please fill in this field'),
        validators.general.minLength(5, 'Length must be at least 5'),
      ]}
    />
    <FormField
      name="lastName"
      component={InputField}
      placeholder="Last name"
      validate={validators.general.required('Please fill in this field')}
    />

    <FormField
      name="choice"
      component={DropdownList}
      placeholder="Make a choice"
      list={[
        {
          value: 'one',
          label: 'Choice 1',
        },
        {
          value: 'two',
          label: 'Choice 2',
        },
      ]}
      validate={validators.general.required('Please fill in this field')}
    />
    <FormField
      name="phonenumber"
      component={NumberField}
      list={[
        {
          value: '00381',
          label: '+381',
        },
        {
          value: '0044',
          label: '+44',
        },
      ]}
      validate={[validators.phone.phoneNumberUndefined('Please enter number')]}
    />
    <FormField
      name="agree"
      component={Checkbox}
      label="I agree"
      validate={validators.general.required(
        'You must agree in order to continue'
      )}
    />
  </Examples.ListView>
</Form>
```

# Form with async validation

---

<Story name="With async errors">
  <Examples.FormWithAsyncError />
</Story>

In the code below there is `mockApiCall` that checks for email validity using simple regex.
If email doesn't meet the rule the api call returns an error.

Otherwise we get a log messages in the console displaying data from the form.

`mockApiCall` is here just an example, important part for the Frontend is the `onSubmit` method.

`onSubmit` checks for errors and by using `form` we are accessing `FormContext` API and asynchronously
setting the error of the field (if there are any errors).

```tsx
const FormWithAsyncError = () => {
  const [form, formRef] = useCallbackRef<FormRef>();

  const mockApiCall = (data: any) => {
    return new Promise<{
      errors: object;
    }>(resolve => {
      let errors: { [key: string]: string };
      if (!/^.+@.+$/.test(data.email)) {
        errors = {};
        errors['email'] = 'Email address appears incorrect';
      }

      setTimeout(
        () =>
          resolve({
            errors,
          }),
        250
      );
    });
  };

  return (
    <Form
      ref={formRef}
      onSubmit={async data => {
        const { errors } = await mockApiCall(data);
        if (errors) {
          Object.entries(errors).forEach(([name, error]) => {
            form.setFieldError(name, error);
          });

          action('Failed submit')(errors);
          return;
        }
        action('Successful submit')(data);
        console.log('Data to submit:', data);
      }}
    >
      <Examples.ListView>
        <FormField
          name="email"
          component={InputField}
          placeholder="Email Address"
          validate={validators.general.required('Please fill in this field')}
        />
        <FormField
          name="firstName"
          component={InputField}
          placeholder="First name"
          validate={validators.general.required('Please fill in this field')}
        />
        <FormField
          name="agree"
          component={Checkbox}
          label="I agree"
          validate={validators.general.required(
            'You must agree in order to continue'
          )}
        />
      </Examples.ListView>
    </Form>
  );
};
```

# Extract values from the form

---

To extract values from the form on the same level where
the form is defined use
`useFormRefValues` hook, pass in the form and then
all the field names you want separated by `,`.

`formValues` is object that contains `firstName` and `lastName`

```tsx
const Form = () => {
  const [form, formRef] = useCallbackRef<FormRef>();

  const formValues = useFormRefValues(form, 'firstName', 'lastName')

  return (
    <Form ref={formRef}>
        <FormField
          name="firstName"
          component={InputField}
          placeholder="First Name"
        />
        <FormField
          name="lastName"
          component={InputField}
          placeholder="Last Name"
        />
        <FormField
          name="email"
          component={InputField}
          placeholder="Email Address"
        />
      </Form>
```

## Props

<Props of={Form} />
